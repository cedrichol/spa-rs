// A static model of a chain of computation.
// This translate the concept of "Expression templates" from many C++ math librairies
// The expression can then be explicitly evaluated.

pub struct Expression<Op: Operation> {
    pub inner: Op,
}

impl<Op: Operation> Expression<Op> {}

pub trait Operation {
    type Output;
    fn eval(self) -> Self::Output;
}

pub struct Addition<A: Operation, B: Operation>
where
    A: Operation,
    B: Operation,
    <A as Operation>::Output: std::ops::Add<<B as Operation>::Output>,
{
    pub a: Expression<A>,
    pub b: Expression<B>,
}

// here lies the real implementation of the addition.
// Everything else is boilerplate (sadly)
default impl<A, B> Operation for Addition<A, B>
where
    A: Operation,
    B: Operation,
    <A as Operation>::Output: std::ops::Add<<B as Operation>::Output>,
{
    type Output = <<A as Operation>::Output as std::ops::Add<<B as Operation>::Output>>::Output;
    fn eval(self) -> Self::Output {
        self.a.inner.eval() + self.b.inner.eval()
    }
}


// Expression impl Op.
// On peut donc avoir Expression<Expression<Expression...>>>
// mais surtout on peut utiliser une seule impl pour chaque std::ops trait
// Pas besoin d'un "impl Add<Expression<B>>" et d'un "impl Add<B: Op>" for Expression<A>.
// Le deuxième suffit !

// Pour démarrer une expression on peut seulement avec tout ça écrire (que des f32 ici)
// let expr = Expression{inner:a} + b + c;
// NB : les expressions ne sont contagieuses que par la gauche
// let expr = a + Expression{inner:b} ne compile pas par défaut.
// Il faut que A impl Add<Op> ET Op

// Si on impl Op for SMatrix (triv)
// et impl Add<B: Op, Output = Expression<...> > for SMatrix (triv)
// Tout est bon !


impl<Op: Operation> Operation for Expression<Op> {
    type Output = Op::Output;
    fn eval(self) -> Self::Output {
        self.inner.eval()
    }
}

impl<A, B> std::ops::Add<B> for Expression<A>
where
    A: Operation,
    B: Operation,
    <A as Operation>::Output: std::ops::Add<<B as Operation>::Output>,
{
    type Output = Expression<Addition<A, B>>;
    fn add(self, b: B) -> Self::Output {
        Self::Output {
            inner: Addition::<A, B> {
                a: self,
                b: Expression { inner: b },
            },
        }
    }
}

impl Operation for f32 {
    type Output = Self;
    fn eval(self) -> Self::Output {
        self
    }
}

impl Operation for &f32 {
    type Output = Self;
    fn eval(self) -> Self::Output {
        self
    }
}

impl Operation for f64 {
    type Output = Self;
    fn eval(self) -> Self::Output {
        self
    }
}

impl Operation for &f64 {
    type Output = Self;
    fn eval(self) -> Self::Output {
        self
    }
}



impl<B> std::ops::Add<Expression<B>> for f64
where
    B: Operation,
    <Self as Operation>::Output: std::ops::Add<<B as Operation>::Output>,
{
    type Output = Expression<<Expression<Self> as std::ops::Add<Expression<B>>>::Output>;
    fn add(self, b: Expression<B>) -> Self::Output {
        Expression {
            inner: Expression { inner: self } + b,
        }
    }
}

impl<B> std::ops::Add<Expression<B>> for &f64
where
    B: Operation,
    <Self as Operation>::Output: std::ops::Add<<B as Operation>::Output>,
{
    type Output = Expression<<Expression<Self> as std::ops::Add<Expression<B>>>::Output>;
    fn add(self, b: Expression<B>) -> Self::Output {
        Expression {
            inner: Expression { inner: self } + b,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn operations_viral_left() {
        // f32 impl Op seulement et Expression est bien viral
        let (a, b, c) = (1.0f32, 2.0f32, 4.0f32);
        let op = Expression { inner: a } + b + &c;
        assert!((op.eval() - 7.0).abs() < 1.0e-10);
    }

    #[test]
    fn operations_viral_right() {
        // f64 impl Op ET Add<Expr>. L'expression est bien virale
        let (a, b, c) = (1.0f64, 2.0f64, 4.0f64);
        let op = &a + Expression { inner: b } + &c;
        assert!((op.eval() - 7.0).abs() < 1.0e-10);
    }
}
